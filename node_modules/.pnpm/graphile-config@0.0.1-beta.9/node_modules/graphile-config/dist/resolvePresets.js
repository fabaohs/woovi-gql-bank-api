"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePresets = exports.isResolvedPreset = void 0;
require("./interfaces.js");
const sort_js_1 = require("./sort.js");
const PROBABLY_A_PLUGIN_NOT_A_PRESET_KEYS = [
    "name",
    "experimental",
    "provides",
    "before",
    "after",
    // To avoid confusion with PostGraphile V4:
    "appendPlugins",
    "prependPlugins",
    "skipPlugins",
];
const PROBABLY_A_PRESET_NOT_A_PLUGIN_KEYS = [
    "plugins",
    "disablePlugins",
    "extends",
];
let inspect;
try {
    inspect = require("util").inspect;
    if (typeof inspect !== "function") {
        throw new Error("Failed to load inspect");
    }
}
catch {
    inspect = (obj) => {
        return Array.isArray(obj) ||
            !obj ||
            Object.getPrototypeOf(obj) === null ||
            Object.getPrototypeOf(obj) === Object.prototype
            ? JSON.stringify(obj)
            : String(obj);
    };
}
function isResolvedPreset(preset) {
    return (preset.plugins && preset.extends?.length === 0) || false;
}
exports.isResolvedPreset = isResolvedPreset;
/**
 * Given a list of presets, resolves the presets and returns the resulting
 * ResolvedPreset (which does not have any `extends`).
 */
function resolvePresets(presets, withAssertions = true) {
    if (presets.length === 1) {
        // Maybe it's already resolved?
        const preset = presets[0];
        if (preset && isResolvedPreset(preset)) {
            return preset;
        }
    }
    const finalPreset = blankResolvedPreset();
    for (const preset of presets) {
        const resolvedPreset = resolvePreset(preset);
        mergePreset(finalPreset, resolvedPreset);
    }
    if (finalPreset.plugins) {
        finalPreset.plugins = (0, sort_js_1.sortWithBeforeAfterProvides)(finalPreset.plugins, "name");
    }
    if (withAssertions) {
        if (finalPreset.disablePlugins && finalPreset.disablePlugins.length > 0) {
            console.warn(`One or more of the plugin(s) entered in your preset's 'disablePlugins' list was not found:\n${finalPreset.disablePlugins
                .map((p) => `  - ${p}`)
                .join("\n")}\nThe list of know plugins is:\n  ${finalPreset.plugins?.map((p) => p.name).join(", ") ?? "-"}`);
        }
    }
    return finalPreset;
}
exports.resolvePresets = resolvePresets;
function isGraphileConfigPreset(foo) {
    if (typeof foo !== "object" || foo === null)
        return false;
    // Check regular prototype
    const prototype = Object.getPrototypeOf(foo);
    if (prototype === null || prototype === Object.prototype) {
        return true;
    }
    // Heavier check, to allow for Jest/VM complexity (where `Object` differs)
    if (String(foo) === "[object Object]") {
        return true;
    }
    return false;
}
function assertPlugin(plugin) {
    if (typeof plugin !== "object" || plugin == null) {
        throw new Error(`Expected plugin, but found '${inspect(plugin)}'`);
    }
    const proto = Object.getPrototypeOf(plugin);
    if (proto !== Object.prototype && proto !== null) {
        throw new Error(`Expected plugin to be a plain object, but found '${inspect(plugin)}'`);
    }
    if (typeof plugin.name !== "string") {
        throw new Error(`Expected plugin to have a string 'name'; found ${inspect(plugin.name)} (${inspect(plugin)})`);
    }
    if (plugin.version != null && typeof plugin.version !== "string") {
        throw new Error(`Expected plugin '${plugin.name}' to have a string 'version'; found ${inspect(plugin.version)}`);
    }
    const keys = Object.keys(plugin);
    const forbiddenKeys = keys.filter(isForbiddenPluginKey);
    if (forbiddenKeys.length) {
        throw new Error(`Expected a GraphileConfig plugin, but found an object with forbidden keys ` +
            `(e.g. keys starting with a capital letter, or a 'default' key). This typically indicates an ` +
            `issue with ESM compatibility or import method, for example ` +
            `doing \`import MyPlugin from 'my-plugin'\` instead of ` +
            `\`import { MyPlugin } from 'my-plugin'\` or vice versa. ` +
            `Forbidden keys: '${forbiddenKeys.join("', '")}', full value: '${inspect(plugin)}'`);
    }
    for (const forbiddenKey of PROBABLY_A_PRESET_NOT_A_PLUGIN_KEYS) {
        if (plugin[forbiddenKey]) {
            throw new Error(`Plugin '${plugin.name}' has '${forbiddenKey}' property which suggests it is a preset rather than a plugin. If it is indeed a preset you should add it to your preset via 'extends' rather than 'plugins'.`);
        }
    }
}
function isForbiddenPresetKey(key) {
    return /^[A-Z_]/.test(key) || key === "default";
}
function isForbiddenPluginKey(key) {
    return /^[A-Z_]/.test(key) || key === "default";
}
/**
 * Turns a preset into a resolved preset (i.e. resolves all its `extends`).
 *
 * @internal
 */
function resolvePreset(preset) {
    if (!isGraphileConfigPreset(preset)) {
        throw new Error(`Expected a GraphileConfig preset (a plain JS object), but found '${inspect(preset)}'`);
    }
    const keys = Object.keys(preset);
    const forbiddenKeys = keys.filter(isForbiddenPresetKey);
    if (forbiddenKeys.length) {
        throw new Error(`Expected a GraphileConfig preset, but found an object with forbidden keys ` +
            `(e.g. keys starting with a capital letter, or a 'default' key). This typically indicates an ` +
            `issue with ESM compatibility or import method, for example ` +
            `doing \`import MyPreset from 'my-preset'\` instead of ` +
            `\`import { MyPreset } from 'my-preset'\` or vice versa. ` +
            `Forbidden keys: '${forbiddenKeys.join("', '")}', full value: '${inspect(preset)}'`);
    }
    try {
        for (const forbiddenKey of PROBABLY_A_PLUGIN_NOT_A_PRESET_KEYS) {
            if (preset[forbiddenKey]) {
                throw new Error(`Preset has '${forbiddenKey}' property which suggests it is a plugin rather than a preset. If it is indeed a plugin you should add it to your preset via 'plugins' rather than 'extends'.`);
            }
        }
        const { extends: presets = [] } = preset;
        const basePreset = resolvePresets(presets, false);
        mergePreset(basePreset, preset);
        const disabled = basePreset.disablePlugins;
        if (disabled) {
            const plugins = new Set(basePreset.plugins);
            const remaining = new Set(disabled);
            for (const plugin of plugins) {
                assertPlugin(plugin);
                if (remaining.has(plugin.name)) {
                    remaining.delete(plugin.name);
                    plugins.delete(plugin);
                }
            }
            basePreset.plugins = [...plugins];
            basePreset.disablePlugins = [...remaining];
        }
        return basePreset;
    }
    catch (e) {
        throw new Error(`Error occurred when resolving preset: ${e}\nPreset: ${inspect(preset)}`);
    }
}
/**
 * Merges `sourcePreset` into existing resolved preset `targetPreset`, ignoring
 * any `extends` on the `sourcePreset`.
 *
 * Note this function uses mutation for performance reasons.
 *
 * @internal
 */
function mergePreset(targetPreset, sourcePreset) {
    if (targetPreset.extends != null && targetPreset.extends.length !== 0) {
        throw new Error("First argument to mergePreset must be a resolved preset");
    }
    const plugins = new Set([
        ...(targetPreset.plugins || []),
        ...(sourcePreset.plugins || []),
    ]);
    targetPreset.plugins = [...plugins];
    if (sourcePreset.disablePlugins) {
        targetPreset.disablePlugins = [
            ...new Set([
                ...(targetPreset.disablePlugins ?? []),
                ...(sourcePreset.disablePlugins ?? []),
            ]),
        ];
    }
    const targetScopes = Object.keys(targetPreset).filter(isScopeKeyForPreset);
    const sourceScopes = Object.keys(sourcePreset).filter(isScopeKeyForPreset);
    const scopes = [...new Set([...targetScopes, ...sourceScopes])];
    for (const scope of scopes) {
        const targetScope = targetPreset[scope];
        const sourceScope = sourcePreset[scope];
        if (targetScope && sourceScope) {
            if (Array.isArray(targetScope) !== Array.isArray(sourceScope)) {
                throw new Error(`${scope} contains an array entry in one preset and a non-array entry in another, this doesn't make sense`);
            }
            else if (Array.isArray(sourceScope)) {
                targetPreset[scope] =
                    sourceScope;
            }
            else {
                targetPreset[scope] =
                    Object.assign(Object.create(null), targetScope, sourceScope);
            }
        }
        else {
            targetPreset[scope] =
                (targetScope || sourceScope);
        }
    }
}
function blankResolvedPreset() {
    return {
        extends: [],
        plugins: [],
        disablePlugins: [],
    };
}
/**
 * Scope keys are all the keys except for the ones explicitly defined in the
 * Preset type (before declaration merging).
 */
function isScopeKeyForPreset(key) {
    return key !== "extends" && key !== "plugins" && key !== "disablePlugins";
}
//# sourceMappingURL=resolvePresets.js.map