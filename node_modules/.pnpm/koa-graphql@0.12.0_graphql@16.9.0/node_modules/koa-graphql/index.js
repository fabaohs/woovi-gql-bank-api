"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.graphqlHTTP = void 0;
const http_errors_1 = __importDefault(require("http-errors"));
const graphql_1 = require("graphql");
const express_graphql_1 = require("express-graphql");
const renderGraphiQL_1 = require("./renderGraphiQL");
/**
 * Middleware for express; takes an options object or function as input to
 * configure behavior, and returns an express middleware.
 */
function graphqlHTTP(options) {
    devAssertIsNonNullable(options, 'GraphQL middleware requires options.');
    return async function middleware(ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const req = ctx.req;
        const request = ctx.request;
        const response = ctx.response;
        // Higher scoped variables are referred to at various stages in the
        // asynchronous state machine below.
        let params;
        let showGraphiQL = false;
        let graphiqlOptions;
        let formatErrorFn = graphql_1.formatError;
        let pretty = false;
        let result;
        try {
            // Parse the Request to get GraphQL request parameters.
            try {
                // Use request.body when req.body is undefined.
                const expressReq = req;
                expressReq.body = (_a = expressReq.body) !== null && _a !== void 0 ? _a : request.body;
                params = await express_graphql_1.getGraphQLParams(expressReq);
            }
            catch (error) {
                // When we failed to parse the GraphQL parameters, we still need to get
                // the options object, so make an options call to resolve just that.
                const optionsData = await resolveOptions();
                pretty = (_b = optionsData.pretty) !== null && _b !== void 0 ? _b : false;
                formatErrorFn =
                    (_d = (_c = optionsData.customFormatErrorFn) !== null && _c !== void 0 ? _c : optionsData.formatError) !== null && _d !== void 0 ? _d : formatErrorFn;
                throw error;
            }
            // Then, resolve the Options to get OptionsData.
            const optionsData = await resolveOptions(params);
            // Collect information from the options data object.
            const schema = optionsData.schema;
            const rootValue = optionsData.rootValue;
            const validationRules = (_e = optionsData.validationRules) !== null && _e !== void 0 ? _e : [];
            const fieldResolver = optionsData.fieldResolver;
            const typeResolver = optionsData.typeResolver;
            const graphiql = (_f = optionsData.graphiql) !== null && _f !== void 0 ? _f : false;
            const extensionsFn = optionsData.extensions;
            const context = (_g = optionsData.context) !== null && _g !== void 0 ? _g : ctx;
            const parseFn = (_h = optionsData.customParseFn) !== null && _h !== void 0 ? _h : graphql_1.parse;
            const executeFn = (_j = optionsData.customExecuteFn) !== null && _j !== void 0 ? _j : graphql_1.execute;
            const validateFn = (_k = optionsData.customValidateFn) !== null && _k !== void 0 ? _k : graphql_1.validate;
            pretty = (_l = optionsData.pretty) !== null && _l !== void 0 ? _l : false;
            formatErrorFn =
                (_o = (_m = optionsData.customFormatErrorFn) !== null && _m !== void 0 ? _m : optionsData.formatError) !== null && _o !== void 0 ? _o : formatErrorFn;
            devAssertIsObject(schema, 'GraphQL middleware options must contain a schema.');
            // GraphQL HTTP only supports GET and POST methods.
            if (request.method !== 'GET' && request.method !== 'POST') {
                throw http_errors_1.default(405, 'GraphQL only supports GET and POST requests.', {
                    headers: { Allow: 'GET, POST' },
                });
            }
            // Get GraphQL params from the request and POST body data.
            const { query, variables, operationName } = params;
            showGraphiQL = canDisplayGraphiQL(request, params) && graphiql !== false;
            if (typeof graphiql !== 'boolean') {
                graphiqlOptions = graphiql;
            }
            // If there is no query, but GraphiQL will be displayed, do not produce
            // a result, otherwise return a 400: Bad Request.
            if (query == null) {
                if (showGraphiQL) {
                    return respondWithGraphiQL(response, graphiqlOptions);
                }
                throw http_errors_1.default(400, 'Must provide query string.');
            }
            // Validate Schema
            const schemaValidationErrors = graphql_1.validateSchema(schema);
            if (schemaValidationErrors.length > 0) {
                // Return 500: Internal Server Error if invalid schema.
                throw http_errors_1.default(500, 'GraphQL schema validation error.', {
                    graphqlErrors: schemaValidationErrors,
                });
            }
            // Parse source to AST, reporting any syntax error.
            let documentAST;
            try {
                documentAST = parseFn(new graphql_1.Source(query, 'GraphQL request'));
            }
            catch (syntaxError) {
                // Return 400: Bad Request if any syntax errors errors exist.
                throw http_errors_1.default(400, 'GraphQL syntax error.', {
                    graphqlErrors: [syntaxError],
                });
            }
            // Validate AST, reporting any errors.
            const validationErrors = validateFn(schema, documentAST, [
                ...graphql_1.specifiedRules,
                ...validationRules,
            ]);
            if (validationErrors.length > 0) {
                // Return 400: Bad Request if any validation errors exist.
                throw http_errors_1.default(400, 'GraphQL validation error.', {
                    graphqlErrors: validationErrors,
                });
            }
            // Only query operations are allowed on GET requests.
            if (request.method === 'GET') {
                // Determine if this GET request will perform a non-query.
                const operationAST = graphql_1.getOperationAST(documentAST, operationName);
                if (operationAST && operationAST.operation !== 'query') {
                    // If GraphiQL can be shown, do not perform this query, but
                    // provide it to GraphiQL so that the requester may perform it
                    // themselves if desired.
                    if (showGraphiQL) {
                        return respondWithGraphiQL(response, graphiqlOptions, params);
                    }
                    // Otherwise, report a 405: Method Not Allowed error.
                    throw http_errors_1.default(405, `Can only perform a ${operationAST.operation} operation from a POST request.`, { headers: { Allow: 'POST' } });
                }
            }
            // Perform the execution, reporting any errors creating the context.
            try {
                result = await executeFn({
                    schema,
                    document: documentAST,
                    rootValue,
                    contextValue: context,
                    variableValues: variables,
                    operationName,
                    fieldResolver,
                    typeResolver,
                });
                response.status = 200;
            }
            catch (contextError) {
                // Return 400: Bad Request if any execution context errors exist.
                throw http_errors_1.default(400, 'GraphQL execution context error.', {
                    graphqlErrors: [contextError],
                });
            }
            // Collect and apply any metadata extensions if a function was provided.
            // https://graphql.github.io/graphql-spec/#sec-Response-Format
            if (extensionsFn) {
                const extensions = await extensionsFn({
                    document: documentAST,
                    variables,
                    operationName,
                    result,
                    context,
                });
                if (extensions != null) {
                    result = { ...result, extensions };
                }
            }
        }
        catch (rawError) {
            // If an error was caught, report the httpError status, or 500.
            const error = http_errors_1.default(500, 
            /* istanbul ignore next: Thrown by underlying library. */
            rawError instanceof Error ? rawError : String(rawError));
            response.status = error.status;
            const { headers } = error;
            if (headers != null) {
                for (const [key, value] of Object.entries(headers)) {
                    response.set(key, value);
                }
            }
            if (error.graphqlErrors == null) {
                const graphqlError = new graphql_1.GraphQLError(error.message, undefined, undefined, undefined, undefined, error);
                result = { data: undefined, errors: [graphqlError] };
            }
            else {
                result = { data: undefined, errors: error.graphqlErrors };
            }
        }
        // If no data was included in the result, that indicates a runtime query
        // error, indicate as such with a generic status code.
        // Note: Information about the error itself will still be contained in
        // the resulting JSON payload.
        // https://graphql.github.io/graphql-spec/#sec-Data
        if (response.status === 200 && result.data == null) {
            response.status = 500;
        }
        // Format any encountered errors.
        const formattedResult = {
            ...result,
            errors: (_p = result.errors) === null || _p === void 0 ? void 0 : _p.map(formatErrorFn),
        };
        // If allowed to show GraphiQL, present it instead of JSON.
        if (showGraphiQL) {
            return respondWithGraphiQL(response, graphiqlOptions, params, formattedResult);
        }
        // Otherwise, present JSON directly.
        const payload = pretty
            ? JSON.stringify(formattedResult, null, 2)
            : formattedResult;
        response.type = 'application/json';
        response.body = payload;
        async function resolveOptions(requestParams) {
            const optionsResult = await Promise.resolve(typeof options === 'function'
                ? options(request, response, ctx, requestParams)
                : options);
            devAssertIsObject(optionsResult, 'GraphQL middleware option function must return an options object or a promise which will be resolved to an options object.');
            if (optionsResult.formatError) {
                // eslint-disable-next-line no-console
                console.warn('`formatError` is deprecated and replaced by `customFormatErrorFn`. It will be removed in version 1.0.0.');
            }
            return optionsResult;
        }
    };
}
exports.graphqlHTTP = graphqlHTTP;
function respondWithGraphiQL(response, options, params, result) {
    const data = {
        query: params === null || params === void 0 ? void 0 : params.query,
        variables: params === null || params === void 0 ? void 0 : params.variables,
        operationName: params === null || params === void 0 ? void 0 : params.operationName,
        result,
    };
    const payload = renderGraphiQL_1.renderGraphiQL(data, options);
    response.type = 'text/html';
    response.body = payload;
}
/**
 * Helper function to determine if GraphiQL can be displayed.
 */
function canDisplayGraphiQL(request, params) {
    // If `raw` false, GraphiQL mode is not enabled.
    // Allowed to show GraphiQL if not requested as raw and this request prefers HTML over JSON.
    return !params.raw && request.accepts(['json', 'html']) === 'html';
}
function devAssertIsObject(value, message) {
    devAssert(value != null && typeof value === 'object', message);
}
function devAssertIsNonNullable(value, message) {
    devAssert(value != null, message);
}
function devAssert(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
        throw new TypeError(message);
    }
}
